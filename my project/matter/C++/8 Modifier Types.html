<center><h1>Modifiers type</h1></center>
<hr>
<p>C++ allows the <b>char, int, </b> and <b>double</b> data types to have modifiers preceding them. A modifier is used to alter the meaning of the base type so that it more precisely fits the needs of various situations.</p>
<p>The data type modifiers are listed here:</p>
<ul class="list">
<li><p>signed</p></li>
<li><p>unsigned</p></li>
<li><p>long</p></li>
<li><p>short</p></li>
</ul>
<p>The modifiers <b>signed, unsigned, long,</b> and <b>short</b> can be applied to integer base types. In addition, <b>signed</b> and <b>unsigned</b> can be applied to char, and <b>long</b> can be applied to double.</p>
<p>The modifiers <b>signed</b> and <b>unsigned</b> can also be used as prefix to <b>long</b> or <b>short</b> modifiers. For example, <b>unsigned long int</b>.</p>
<p>C++ allows a shorthand notation for declaring <b>unsigned, short,</b> or <b>long</b> integers. You can simply use the word <b>unsigned, short,</b> or <b>long</b>, without the int. The int is implied. For example, the following two statements both declare unsigned integer variables.</p>
<pre class="result notranslate">
unsigned x;
unsigned int y;
</pre>
<p>To understand the difference between the way that signed and unsigned integer modifiers are interpreted by C++, you should run the following short program:</p>
<pre class="prettyprint notranslate tryit">
#include &lt;iostream&gt;
using namespace std;
 
/* This program shows the difference between
 * signed and unsigned integers.
*/
int main() {
   short int i;           // a signed short integer
   short unsigned int j;  // an unsigned short integer

   j = 50000;

   i = j;
   cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j;

   return 0;
}
</pre>
<p>When this program is run, following is the output:</p>
<pre class="result notranslate">
-15536 50000
</pre>
<p>The above result is because the bit pattern that represents 50,000 as a short unsigned integer is interpreted as -15,536 by a short.</p>
<h2>Type Qualifiers in C++</h2>
<p>The type qualifiers provide additional information about the variables they precede.</p>
<table class="table table-bordered">
<tr>
<th>Qualifier</th>
<th>Meaning</th>
</tr>
<tr>
<td>const</td>
<td>Objects of type <b>const</b> cannot be changed by your program during execution</td>
</tr>
<tr>
<td>volatile</td>
<td>The modifier <b>volatile</b> tells the compiler that a variable's value may be changed in ways not explicitly specified by the program.</td>
</tr>
<tr>
<td>restrict</td>
<td>A pointer qualified by <b>restrict</b> is initially the only means by which the object it points to can be accessed. Only C99 adds a new type qualifier called restrict.</td>
</tr>
</table>
<hr />